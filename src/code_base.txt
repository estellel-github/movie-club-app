Updated on 01/19/25 11:12:43 AM CET by bubuntu

--------------------------
Path: services/auth.service.ts

import argon2 from "argon2";
import type { User } from "../models/user.entity.js";
import type { Repository } from "typeorm";
import { generateToken } from "../utils/jwt.js";
import { excludeFields } from "../utils/excludeFields.js";
import type {
  RegisterRequest,
  LoginRequest,
  RegisterResponse,
  LoginResponse,
} from "../types/auth.types.js";
import { userStatuses } from "../models/user.entity.js";
import { CustomError } from "utils/customError.js";

export class AuthService {
  private userRepo: Repository<User>;

  constructor(userRepo: Repository<User>) {
    this.userRepo = userRepo;
  }

  async register({
    email,
    password,
    intro_msg,
    username,
  }: RegisterRequest): Promise<RegisterResponse> {
    if (!email || !password || !intro_msg || !username) {
      throw new CustomError("Missing required fields", 400); // Bad Request
    }

    const existingEmail = await this.userRepo.findOneBy({ email });
    if (existingEmail) {
      throw new CustomError("Email already exists", 409); // Conflict
    }

    const existingUsername = await this.userRepo.findOneBy({ username });
    if (existingUsername) {
      throw new CustomError("Username already exists", 409); // Conflict
    }

    const hashedPassword = await argon2.hash(password);
    const user = this.userRepo.create({
      email,
      password: hashedPassword,
      intro_msg,
      username,
      status: userStatuses[0], // Default status
    });

    const savedUser = await this.userRepo.save(user);

    const userWithoutPassword = excludeFields(savedUser, ["password"]);
    return {
      message: "User registered successfully",
      user: userWithoutPassword,
    };
  }

  async login({ email, password }: LoginRequest): Promise<LoginResponse> {
    if (!email || !password) {
      throw new CustomError("Missing email or password", 400); // Bad Request
    }

    const user = await this.userRepo.findOneBy({ email });
    if (!user || !(await argon2.verify(user.password, password))) {
      throw new CustomError("Invalid email or password", 401); // Unauthorized
    }

    const token = generateToken({ user_id: user.user_id, role: user.role });
    return { token };
  }
}

--------------------------
Path: services/event.service.ts

import type { Repository } from "typeorm";
import { AppDataSource } from "../config/database.js";
import { Event } from "../models/event.entity.js";

export class EventService {
  private eventRepo: Repository<Event>;

  constructor() {
    this.eventRepo = AppDataSource.getRepository(Event);
  }

  async getAllEvents(): Promise<Event[]> {
    return this.eventRepo.find();
  }

  async getEventById(event_id: string): Promise<Event | null> {
    return this.eventRepo.findOneBy({ event_id });
  }

  async createEvent(data: Partial<Event>): Promise<Event> {
    const event = this.eventRepo.create(data);
    return this.eventRepo.save(event);
  }

  async updateEvent(event_id: string, data: Partial<Event>): Promise<Event> {
    const event = await this.eventRepo.findOneBy({ event_id });
    if (!event) throw new Error("Event not found");

    Object.assign(event, data);
    return this.eventRepo.save(event);
  }

  async deleteEvent(event_id: string): Promise<void> {
    const result = await this.eventRepo.delete(event_id);
    if (result.affected === 0) throw new Error("Event not found");
  }
}

--------------------------
Path: services/movie.service.ts

import type { Repository } from "typeorm";
import { AppDataSource } from "../config/database.js";
import { Movie } from "../models/movie.entity.js";

export class MovieService {
  private movieRepo: Repository<Movie>;

  constructor() {
    this.movieRepo = AppDataSource.getRepository(Movie);
  }

  async getAllMovies(): Promise<Movie[]> {
    const movies = await this.movieRepo.find();
    return movies;
  }

  async getMovieById(movie_id: string): Promise<Movie | null> {
    const movie = await this.movieRepo.findOneBy({ movie_id });
    if (!movie) throw new Error("Movie not found");
    return movie;
  }

  async createMovie(data: Partial<Movie>, user_id: string): Promise<Movie> {
    const movie = this.movieRepo.create({ ...data, added_by_user_id: user_id });
    return this.movieRepo.save(movie);
  }

  async updateMovie(movie_id: string, data: Partial<Movie>): Promise<Movie> {
    const movie = await this.movieRepo.findOneBy({ movie_id });
    if (!movie) throw new Error("Movie not found");

    Object.assign(movie, data);
    return this.movieRepo.save(movie);
  }

  async deleteMovie(movie_id: string): Promise<void> {
    const result = await this.movieRepo.delete(movie_id);
    if (result.affected === 0) throw new Error("Movie not found");
  }
}

--------------------------
Path: services/user.service.ts

import type { Repository } from "typeorm";
import { AppDataSource } from "../config/database.js";
import { User } from "../models/user.entity.js";
import { excludeFields } from "../utils/excludeFields.js";

export class UserService {
  private userRepo: Repository<User>;

  constructor() {
    this.userRepo = AppDataSource.getRepository(User);
  }

  async getUserById(user_id: string): Promise<Partial<User>> {
    const user = await this.userRepo.findOneBy({ user_id });
    if (!user) throw new Error("User not found");

    return excludeFields(user, ["password"]);
  }

  async updateUser(
    user_id: string,
    data: Partial<User>,
  ): Promise<Partial<User>> {
    const user = await this.getUserById(user_id);
    if (!user) throw new Error("User not found");

    Object.assign(user, data);
    const updatedUser = await this.userRepo.save(user);
    return excludeFields(updatedUser, ["password"]);
  }

  async deleteUser(user_id: string): Promise<void> {
    const result = await this.userRepo.delete(user_id);
    if (result.affected === 0) throw new Error("User not found");
  }
}

--------------------------
Path: services/rsvp.service.ts

import type { Repository } from "typeorm";
import { AppDataSource } from "../config/database.js";
import { RSVP } from "../models/rsvp.entity.js";
import { Event } from "../models/event.entity.js";

export class RSVPService {
  private rsvpRepo: Repository<RSVP>;
  private eventRepo: Repository<Event>;

  constructor() {
    this.rsvpRepo = AppDataSource.getRepository(RSVP);
    this.eventRepo = AppDataSource.getRepository(Event);
  }

  async createRSVP(event_id: string, user_id: string): Promise<RSVP> {
    const event = await this.eventRepo.findOneBy({ event_id });
    if (!event) {
      throw new Error("Event not found");
    }

    const attendeeCount = await this.rsvpRepo.countBy({ event_id });
    if (attendeeCount >= event.max_attendees) {
      throw new Error("Event is full");
    }

    const existingRSVP = await this.rsvpRepo.findOneBy({ event_id, user_id });
    if (existingRSVP) {
      throw new Error("User has already RSVP'd to this event");
    }

    const rsvp = this.rsvpRepo.create({
      event_id,
      user_id,
      status: "going",
    });
    return this.rsvpRepo.save(rsvp);
  }

  async getRSVPsForEvent(event_id: string): Promise<RSVP[]> {
    return this.rsvpRepo.findBy({ event_id });
  }

  async updateRSVP(rsvp_id: string, status: RSVP["status"]): Promise<RSVP> {
    const rsvp = await this.rsvpRepo.findOneBy({ rsvp_id });
    if (!rsvp) {
      throw new Error("RSVP not found");
    }

    rsvp.status = status;
    return this.rsvpRepo.save(rsvp);
  }

  async deleteRSVP(rsvp_id: string): Promise<void> {
    const result = await this.rsvpRepo.delete(rsvp_id);
    if (result.affected === 0) {
      throw new Error("RSVP not found");
    }
  }
}

--------------------------
Path: services/comment.service.ts

import type { Repository } from "typeorm";
import { AppDataSource } from "../config/database.js";
import { Comment } from "../models/comment.entity.js";

export class CommentService {
  private commentRepo: Repository<Comment>;

  constructor() {
    this.commentRepo = AppDataSource.getRepository(Comment);
  }

  async getCommentsByEvent(event_id: string): Promise<Comment[]> {
    return this.commentRepo.find({ where: { event_id } });
  }

  async createComment(data: Partial<Comment>): Promise<Comment> {
    const comment = this.commentRepo.create(data);
    return this.commentRepo.save(comment);
  }

  async updateComment(
    comment_id: string,
    user_id: string,
    content: string,
  ): Promise<Comment> {
    const comment = await this.commentRepo.findOneBy({ comment_id, user_id });
    if (!comment) throw new Error("Comment not found or unauthorized");
    comment.content = content;
    return this.commentRepo.save(comment);
  }

  async deleteComment(comment_id: string, user_id: string): Promise<void> {
    const comment = await this.commentRepo.findOneBy({ comment_id, user_id });
    if (!comment) throw new Error("Comment not found or unauthorized");
    await this.commentRepo.delete(comment_id);
  }
}

--------------------------
Path: utils/customError.ts

export class CustomError extends Error {
  public statusCode: number;

  constructor(message: string, statusCode = 500) {
    super(message);
    this.statusCode = statusCode;
    Object.setPrototypeOf(this, CustomError.prototype);
  }
}

--------------------------
Path: utils/excludeFields.ts

export function excludeFields<T, Key extends keyof T>(
  obj: T,
  keys: Key[],
): Omit<T, Key> {
  const newObj = { ...obj };
  for (const key of keys) {
    delete newObj[key];
  }
  return newObj;
}

--------------------------
Path: utils/jwt.ts

import jwt from "jsonwebtoken";

export interface DecodedToken {
  user_id: string;
  role: string;
}

const JWT_SECRET = process.env.JWT_SECRET || "your_jwt_secret";

export const generateToken = (payload: object, expiresIn = "1h"): string => {
  return jwt.sign(payload, JWT_SECRET, { expiresIn });
};

export const verifyToken = (token: string): DecodedToken => {
  return jwt.verify(token, JWT_SECRET) as DecodedToken;
};

--------------------------
Path: index.ts

import express from "express";
import dotenv from "dotenv";
import { connectDB } from "./config/database.js";
import type { Server } from "http";
import "reflect-metadata";

import adminRoutes from "./routes/admin.route.js";
import authRoutes from "./routes/auth.route.js";
import userRoutes from "./routes/user.route.js";
import movieRoutes from "./routes/movie.route.js";
import eventRoutes from "./routes/event.route.js";
import rsvpRoutes from "./routes/rsvp.route.js";
import commentRoutes from "./routes/comment.route.js";
import healthRoutes from "./routes/health.route.js";
import { errorHandler } from "middleware/errorHandler.middleware.js";

dotenv.config();

const app = express();
const PORT = process.env.PORT ? parseInt(process.env.PORT, 10) : 3000;

// Middleware to parse JSON request bodies
app.use(express.json());

// Routes
app.use("/api/admin", adminRoutes);
app.use("/api/auth", authRoutes);
app.use("/api/profile", userRoutes);
app.use("/api/movies", movieRoutes);
app.use("/api/events", eventRoutes);
app.use("/api/rsvps", rsvpRoutes);
app.use("/api/comments", commentRoutes);
app.use("/api/health", healthRoutes);

// Error Handler
app.use(errorHandler);

// Start server and connect to the database
if (process.env.NODE_ENV !== "test") {
  (async () => {
    try {
      await connectDB();

      const server: Server = app.listen(PORT, "0.0.0.0", () => {
        console.log(`âœ… Server running at http://localhost:${PORT}`);
      });

      server.on("error", (error: any) => {
        if (error.code === "EADDRINUSE") {
          console.error(
            `âŒ Port ${PORT} is already in use. Choose a different port.`,
          );
        } else if (error.code === "EACCES") {
          console.error(
            `âŒ Permission denied. Unable to bind to port ${PORT}.`,
          );
        } else {
          console.error("âŒ Server encountered an error:", error);
        }
        process.exit(1);
      });
    } catch (error) {
      console.error("Server encountered an error:", error);
      process.exit(1);
    }
  })();
}

--------------------------
Path: validators/auth.validators.ts

import { z } from "zod";

const strongPassword = z
  .string()
  .min(8, "Password must be at least 8 characters long")
  .max(64, "Password must not exceed 64 characters")
  .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
  .regex(/[a-z]/, "Password must contain at least one lowercase letter")
  .regex(/[0-9]/, "Password must contain at least one number")
  .regex(/[\W_]/, "Password must contain at least one special character");

export const registerSchema = z.object({
  email: z.string().email("Invalid email format"),
  password: strongPassword,
  username: z
    .string()
    .min(3, "Username must be at least 3 characters long")
    .max(30, "Username must not exceed 30 characters"),
  intro_msg: z
    .string()
    .max(255, "Intro message must not exceed 255 characters"),
});

export const loginSchema = z.object({
  email: z.string().email("Invalid email format"),
  password: z.string(),
});

--------------------------
Path: models/comment.entity.ts

import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class Comment {
  @PrimaryGeneratedColumn("uuid")
  comment_id!: string;

  @Column("uuid", { nullable: false })
  event_id!: string;

  @Column("uuid", { nullable: false })
  user_id!: string;

  @Column("text")
  content!: string;

  @Column("timestamp", { default: () => "CURRENT_TIMESTAMP" })
  created_at!: Date;

  @Column("timestamp", {
    default: () => "CURRENT_TIMESTAMP",
    onUpdate: "CURRENT_TIMESTAMP",
  })
  updated_at!: Date;
}

--------------------------
Path: models/rsvp.entity.ts

import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

export const rsvpStatuses = ["going", "waitlisted", "not going"] as const;
export type RSVPStatus = (typeof rsvpStatuses)[number];

@Entity()
export class RSVP {
  @PrimaryGeneratedColumn("uuid")
  rsvp_id!: string;

  @Column("uuid", { nullable: false })
  event_id!: string;

  @Column("uuid", { nullable: false })
  user_id!: string;

  @Column({ type: "enum", enum: rsvpStatuses, default: rsvpStatuses[0] })
  status!: RSVPStatus;

  @Column("int", { default: 0 })
  priority!: number;

  @Column("timestamp", { default: () => "CURRENT_TIMESTAMP" })
  created_at!: Date;
}

--------------------------
Path: models/movie.entity.ts

import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class Movie {
  @PrimaryGeneratedColumn("uuid")
  movie_id!: string;

  @Column("varchar", { length: 255 })
  title!: string;

  @Column("text")
  description!: string;

  @Column("varchar", { length: 255 })
  director!: string;

  @Column("int")
  release_year!: number;

  @Column("varchar", { length: 255 })
  genre!: string;

  @Column("varchar", { length: 255 })
  language!: string;

  @Column("int")
  runtime_minutes!: number;

  @Column("text", { nullable: true })
  cover_image_url?: string;

  @Column("uuid", { nullable: false })
  added_by_user_id!: string;

  @Column("timestamp", { default: () => "CURRENT_TIMESTAMP" })
  created_at!: Date;

  @Column("timestamp", {
    default: () => "CURRENT_TIMESTAMP",
    onUpdate: "CURRENT_TIMESTAMP",
  })
  updated_at!: Date;
}

--------------------------
Path: models/user.entity.ts

import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

export const userStatuses = ["active", "suspended"] as const;
export type UserStatus = (typeof userStatuses)[number];

export const userRoles = ["user", "host", "admin"] as const;
export type UserRole = (typeof userRoles)[number];

@Entity()
export class User {
  @PrimaryGeneratedColumn("uuid")
  user_id!: string;

  @Column({ type: "varchar", length: 255, unique: true })
  email!: string;

  @Column({ type: "varchar", length: 255, unique: true })
  username!: string;

  @Column({ type: "varchar", length: 255 })
  password!: string;

  @Column("text")
  intro_msg!: string;

  @Column({
    type: "enum",
    enum: userRoles,
    default: userRoles[0],
  })
  role!: UserRole;

  @Column({
    type: "enum",
    enum: userStatuses,
    default: userStatuses[0],
  })
  status!: UserStatus;

  @Column({ type: "timestamp", default: () => "CURRENT_TIMESTAMP" })
  created_at!: Date;

  @Column({
    type: "timestamp",
    default: () => "CURRENT_TIMESTAMP",
    onUpdate: "CURRENT_TIMESTAMP",
  })
  updated_at!: Date;
}

--------------------------
Path: models/event.entity.ts

import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class Event {
  @PrimaryGeneratedColumn("uuid")
  event_id!: string;

  @Column("varchar", { length: 255 })
  title!: string;

  @Column("text")
  description!: string;

  @Column("timestamp")
  date!: Date;

  @Column("varchar", { length: 255 })
  location!: string;

  @Column("timestamp", { default: () => "CURRENT_TIMESTAMP" })
  created_at!: Date;

  @Column("timestamp", {
    default: () => "CURRENT_TIMESTAMP",
    onUpdate: "CURRENT_TIMESTAMP",
  })
  updated_at!: Date;

  @Column("uuid", { nullable: false })
  movie_id!: string;

  @Column("uuid", { nullable: true })
  host_id!: string | null;

  @Column("int")
  max_attendees!: number;
}

--------------------------
Path: routes/movie.route.ts

import { Router } from "express";
import {
  getAllMovies,
  getMovieById,
  createMovie,
  updateMovie,
  deleteMovie,
} from "../controllers/movie.controller.js";
import { authenticate } from "../middleware/auth.middleware.js"; // Auth middleware

const router = Router();

// Public routes
router.get("/", getAllMovies);
router.get("/:id", getMovieById);

// Protected routes
router.post("/", authenticate, createMovie);
router.patch("/:id", authenticate, updateMovie);
router.delete("/:id", authenticate, deleteMovie);

export default router;

--------------------------
Path: routes/comment.route.ts

import { Router } from "express";
import {
  getCommentsByEvent,
  createComment,
  updateComment,
  deleteComment,
} from "../controllers/comment.controller.js";
import { authenticate } from "../middleware/auth.middleware.js";

const router = Router();

router.get("/event/:eventId", getCommentsByEvent);
router.post("/event/:eventId", authenticate, createComment);
router.patch("/event/:eventId/:commentId", authenticate, updateComment);
router.delete("/event/:eventId/:commentId", authenticate, deleteComment);

export default router;

--------------------------
Path: routes/event.route.ts

import { Router } from "express";
import {
  getAllEvents,
  getEventById,
  createEvent,
  updateEvent,
  deleteEvent,
} from "../controllers/event.controller.js";
import { authenticate } from "../middleware/auth.middleware.js"; // Auth middleware

const router = Router();

// Public routes
router.get("/", getAllEvents);
router.get("/:id", getEventById);

// Protected routes
router.post("/", authenticate, createEvent);
router.patch("/:id", authenticate, updateEvent);
router.delete("/:id", authenticate, deleteEvent);

export default router;

--------------------------
Path: routes/admin.route.ts

import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware.js";
import {
  suspendUser,
  updateUserRole,
} from "../controllers/admin.controller.js";

const router = Router();

// Admin routes
router.patch("/suspend/:userId", authenticate, suspendUser);
router.patch("/roles/:userId", authenticate, updateUserRole);

export default router;

--------------------------
Path: routes/auth.route.ts

import { Router } from "express";
import { register, login } from "../controllers/auth.controller.js";
import { validate } from "middleware/validation.middleware.js";
import { registerSchema, loginSchema } from "../validators/auth.validators.js";

const router = Router();

router.post("/register", validate(registerSchema), register);
router.post("/login", validate(loginSchema), login);

export default router;

--------------------------
Path: routes/user.route.ts

import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware.js";
import {
  getUserProfile,
  updateUserProfile,
  deleteUserAccount,
} from "../controllers/user.controller.js";

const router = Router();

// Get user profile
router.get("/", authenticate, getUserProfile);

// Update user profile
router.patch("/update", authenticate, updateUserProfile);

// Delete user account
router.delete("/delete", authenticate, deleteUserAccount);

export default router;

--------------------------
Path: routes/health.route.ts

import { Router } from "express";

const router = Router();

router.get("/", (req, res) => {
  res.status(200).json({ message: "Service is running!" });
});

export default router;

--------------------------
Path: routes/rsvp.route.ts

import { Router } from "express";
import { authenticate } from "../middleware/auth.middleware.js";
import {
  createRSVP,
  getRSVPsForEvent,
  updateRSVP,
  deleteRSVP,
} from "../controllers/rsvp.controller.js";

const router = Router();

// Protected routes
router.post("/:id", authenticate, createRSVP); // RSVP to an event
router.get("/:id", authenticate, getRSVPsForEvent); // Get RSVPs for an event
router.patch("/:id", authenticate, updateRSVP); // Update RSVP status
router.delete("/:id", authenticate, deleteRSVP); // Delete RSVP

export default router;

--------------------------
Path: config/env.ts

import dotenv from "dotenv";

const envFile = (() => {
  switch (process.env.NODE_ENV) {
    case "production":
      return ".env.prod";
    case "test":
      return ".env.test";
    case "local":
      return ".env.local";
    default:
      return ".env.dev";
  }
})();

dotenv.config({ path: envFile });

export const config = {
  port: process.env.PORT,
  db: {
    host: process.env.POSTGRES_HOST,
    port: Number(process.env.POSTGRES_PORT),
    user: process.env.POSTGRES_USER,
    password: process.env.POSTGRES_PASSWORD,
    name: process.env.POSTGRES_DB,
  },
  jwtSecret: process.env.JWT_SECRET,
  env: process.env.NODE_ENV,
};

--------------------------
Path: config/seed.ts

import { faker } from "@faker-js/faker";
import argon2 from "argon2";
import { AppDataSource } from "../config/database.js";
import { User } from "../models/user.entity.js";
import { Movie } from "../models/movie.entity.js";
import { Event } from "../models/event.entity.js";
import { Comment } from "../models/comment.entity.js";
import { rsvpStatuses, RSVP } from "../models/rsvp.entity.js";

const seedDatabase = async () => {
  try {
    await AppDataSource.initialize();
    console.log("ðŸ”— Database connected for seeding.");

    const userRepo = AppDataSource.getRepository(User);
    const movieRepo = AppDataSource.getRepository(Movie);
    const eventRepo = AppDataSource.getRepository(Event);
    const commentRepo = AppDataSource.getRepository(Comment);
    const rsvpRepo = AppDataSource.getRepository(RSVP);

    const isDatabaseSeeded = async () => {
      const userCount = await userRepo.count();
      return userCount > 0;
    };

    if (await isDatabaseSeeded()) {
      console.log("ðŸš¨ Database already seeded. No changes made.");
      process.exit(0);
    }

    const predefinedPassword = process.env.SEED_PASSWORD || "Test@123";
    const hashedPassword = await argon2.hash(predefinedPassword);

    // Seed Users
    const users = [];
    for (let i = 0; i < 10; i++) {
      const user = userRepo.create({
        email: faker.internet.email(),
        username: faker.internet.username(),
        password: hashedPassword,
        intro_msg: faker.lorem.sentence(),
      });
      users.push(await userRepo.save(user));
    }
    console.log(
      `âœ… ${users.length} Users seeded with default password: ${predefinedPassword}`,
    );

    // Seed Movies
    const movies = [];
    for (let i = 0; i < 50; i++) {
      const movie = movieRepo.create({
        title: faker.lorem.words(3),
        description: faker.lorem.sentences(2),
        director: faker.person.fullName(),
        release_year: faker.date.past().getFullYear(),
        genre: faker.helpers.arrayElement(["Drama", "Comedy", "Action"]),
        language: faker.helpers.arrayElement(["English", "French", "Spanish"]),
        runtime_minutes: faker.number.int({ min: 1, max: 500 }),
        added_by_user_id:
          users[faker.number.int({ min: 0, max: users.length - 1 })].user_id,
      });
      movies.push(await movieRepo.save(movie));
    }
    console.log(`âœ… ${movies.length} Movies seeded.`);

    // Seed Events
    const events = [];
    for (let i = 0; i < 15; i++) {
      const event = eventRepo.create({
        title: faker.lorem.words(3),
        description: faker.lorem.sentences(2),
        date: faker.date.future(),
        location: faker.location.city(),
        movie_id:
          movies[faker.number.int({ min: 0, max: movies.length - 1 })].movie_id,
        host_id:
          users[faker.number.int({ min: 0, max: users.length - 1 })].user_id,
        max_attendees: faker.number.int({ min: 10, max: 100 }),
      });
      events.push(await eventRepo.save(event));
    }
    console.log(`âœ… ${events.length} Events seeded.`);

    // Seed RSVPs
    const rsvps = [];
    for (const event of events) {
      const attendeeCount = faker.number.int({
        min: 0,
        max: event.max_attendees,
      });
      for (let i = 0; i < attendeeCount; i++) {
        const rsvp = rsvpRepo.create({
          event_id: event.event_id,
          user_id:
            users[faker.number.int({ min: 0, max: users.length - 1 })].user_id,
          status: faker.helpers.arrayElement(rsvpStatuses),
          priority: faker.number.int({ min: 0, max: 5 }),
        });
        rsvps.push(await rsvpRepo.save(rsvp));
      }
    }
    console.log(`âœ… ${rsvps.length} RSVPs seeded.`);

    // Seed Comments
    const comments = [];
    for (const event of events) {
      for (let i = 0; i < faker.number.int({ min: 3, max: 10 }); i++) {
        const comment = commentRepo.create({
          event_id: event.event_id,
          user_id:
            users[faker.number.int({ min: 0, max: users.length - 1 })].user_id,
          content: faker.lorem.sentences(2),
        });
        comments.push(await commentRepo.save(comment));
      }
    }
    console.log(`âœ… ${comments.length} Comments seeded.`);

    await AppDataSource.destroy();
    console.log("ðŸŒ± Seeding completed. Database is ready for use!");
  } catch (error) {
    console.error("âŒ Error during database seeding:", error);
    await AppDataSource.destroy();
    process.exit(1);
  }
};

seedDatabase();

--------------------------
Path: config/database.ts

import "reflect-metadata";
import { DataSource } from "typeorm";
import { config } from "./env.js";

import { User } from "../models/user.entity.js";
import { Movie } from "../models/movie.entity.js";
import { Event } from "../models/event.entity.js";
import { RSVP } from "../models/rsvp.entity.js";
import { Comment } from "../models/comment.entity.js";

export const AppDataSource = new DataSource({
  type: "postgres",
  host: config.db.host,
  port: config.db.port,
  username: config.db.user,
  password: config.db.password,
  database: config.db.name,
  entities: [User, Movie, Event, RSVP, Comment],
  synchronize: config.env === "development",
  logging: config.env === "development",
});

export const connectDB = async () => {
  let retries = 5;
  console.log("ðŸ”§ Attempting database connection...");
  while (retries) {
    try {
      await AppDataSource.initialize();
      console.log(`âœ… Database connected: ${config.db.name}`);
      break;
    } catch (error) {
      console.error(`âŒ Database connection failed: ${error}`);
      retries -= 1;
      console.log(`â³ Retrying... (${retries} retries left)`);
      retries -= 1;
      await new Promise((res) => setTimeout(res, 5000));
    }
  }
  if (!retries) {
    console.error("âŒ Database connection failed after all retries.");
    process.exit(1);
  }
};

--------------------------
Path: combined.txt


--------------------------
Path: __tests__/dummy.test.ts

describe("Dummy Test", () => {
  it("should pass", () => {
    expect(1 + 1).toBe(2);
  });
});

--------------------------
Path: controllers/rsvp.controller.ts

import type { Request, Response } from "express";
import { RSVPService } from "../services/rsvp.service.js";

const rsvpService = new RSVPService();

export const createRSVP = async (req: Request, res: Response) => {
  try {
    console.log("Incoming request to RSVP:", req.params.id);

    const { id: event_id } = req.params;

    if (!req.user) {
      return res
        .status(401)
        .json({ error: "Unauthorized: User not authenticated" });
    }

    const { user_id } = req.user;

    const rsvp = await rsvpService.createRSVP(event_id, user_id);
    res.status(201).json(rsvp);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const getRSVPsForEvent = async (req: Request, res: Response) => {
  try {
    if (!req.user) {
      return res
        .status(401)
        .json({ error: "Unauthorized: User not authenticated" });
    }

    const { id: event_id } = req.params;
    const rsvps = await rsvpService.getRSVPsForEvent(event_id);
    res.status(200).json(rsvps);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const updateRSVP = async (req: Request, res: Response) => {
  try {
    const { id: rsvp_id } = req.params;
    const { status } = req.body;

    const rsvp = await rsvpService.updateRSVP(rsvp_id, status);
    res.status(200).json(rsvp);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const deleteRSVP = async (req: Request, res: Response) => {
  try {
    const { id: rsvp_id } = req.params;

    await rsvpService.deleteRSVP(rsvp_id);
    res.status(204).send();
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

--------------------------
Path: controllers/admin.controller.ts

import type { Request, Response } from "express";
import { UserService } from "../services/user.service.js";
import { userRoles, userStatuses } from "../models/user.entity.js";

const userService = new UserService();

// Suspend User
export const suspendUser = async (req: Request, res: Response) => {
  try {
    const { userId } = req.params;
    const user = await userService.getUserById(userId);

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    if (user.status === userStatuses[1]) {
      return res.status(400).json({ error: "User already suspended" });
    }

    const updatedUser = await userService.updateUser(userId, {
      status: "suspended",
    });

    res.status(200).json({
      message: "User suspended successfully",
      userId: updatedUser.user_id,
    });
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    } else {
      res.status(500).json({ error: "Unknown error" });
    }
  }
};

// Update User Roles
export const updateUserRole = async (req: Request, res: Response) => {
  try {
    const { userId } = req.params;
    const { role } = req.body;

    // Validate role
    const validRoles = userRoles;
    if (!validRoles.includes(role)) {
      return res.status(400).json({ error: "Invalid role specified" });
    }

    const user = await userService.getUserById(userId);

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const updatedUser = await userService.updateUser(userId, { role });

    res.status(200).json({
      message: "Role updated successfully",
      userId: updatedUser.user_id,
      role: updatedUser.role,
    });
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    } else {
      res.status(500).json({ error: "Unknown error" });
    }
  }
};

--------------------------
Path: controllers/user.controller.ts

import type { Response } from "express";
import { UserService } from "../services/user.service.js";
import type { AuthenticatedRequest } from "../types/express.d.ts";

const userService = new UserService();

export const getUserProfile = async (
  req: AuthenticatedRequest,
  res: Response,
) => {
  console.log(`Request received: ${req.method} ${req.url}`);
  try {
    const { user_id } = req.user!;
    const user = await userService.getUserById(user_id);
    if (!user) return res.status(404).json({ error: "User not found" });

    const userProfile = { ...user, password: undefined };
    res.status(200).json(userProfile);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(500).json({ error: error.message });
    } else {
      res.status(500).json({ error: "Unknown error" });
    }
  }
};

export const updateUserProfile = async (
  req: AuthenticatedRequest,
  res: Response,
) => {
  try {
    const { user_id } = req.user!;
    const updatedUser = await userService.updateUser(user_id, req.body);
    res
      .status(200)
      .json({ message: "Profile updated successfully", user: updatedUser });
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const deleteUserAccount = async (
  req: AuthenticatedRequest,
  res: Response,
) => {
  try {
    const { user_id } = req.user!;
    await userService.deleteUser(user_id);
    res.status(204).send();
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

--------------------------
Path: controllers/comment.controller.ts

import type { Request, Response } from "express";
import { CommentService } from "../services/comment.service.js";

const commentService = new CommentService();

export const getCommentsByEvent = async (req: Request, res: Response) => {
  try {
    const comments = await commentService.getCommentsByEvent(
      req.params.eventId,
    );
    res.status(200).json(comments);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const createComment = async (req: Request, res: Response) => {
  try {
    const { content } = req.body;
    const user_id = req.user?.user_id;
    const event_id = req.params.eventId;

    const newComment = await commentService.createComment({
      content,
      user_id,
      event_id,
    });
    res.status(201).json(newComment);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const updateComment = async (req: Request, res: Response) => {
  try {
    const { content } = req.body;
    const user_id = req.user?.user_id;

    if (!user_id) {
      throw new Error("User ID is required");
    }
    const { commentId: comment_id } = req.params;

    const updatedComment = await commentService.updateComment(
      comment_id,
      user_id,
      content,
    );

    res.status(200).json(updatedComment);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const deleteComment = async (req: Request, res: Response) => {
  try {
    const user_id = req.user?.user_id;
    if (!user_id) {
      throw new Error("User ID is required");
    }
    const { commentId: comment_id } = req.params;

    await commentService.deleteComment(comment_id, user_id);
    res.status(204).send();
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

--------------------------
Path: controllers/movie.controller.ts

import type { Request, Response } from "express";
import { MovieService } from "../services/movie.service.js";

const movieService = new MovieService();

export const getAllMovies = async (req: Request, res: Response) => {
  try {
    const movies = await movieService.getAllMovies();
    if (!movies) return res.status(404).json({ error: "No movies found" });
    res.status(200).json(movies);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const getMovieById = async (req: Request, res: Response) => {
  try {
    const movie = await movieService.getMovieById(req.params.id);
    if (!movie) return res.status(404).json({ error: "Movie not found" });
    res.status(200).json(movie);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const createMovie = async (req: Request, res: Response) => {
  try {
    if (!req.user || !req.user.user_id) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const user_id = req.user.user_id;
    const movie = await movieService.createMovie(req.body, user_id);
    res.status(201).json(movie);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const updateMovie = async (req: Request, res: Response) => {
  try {
    const movie = await movieService.updateMovie(req.params.id, req.body);
    if (!movie)
      res
        .status(404)
        .json({ error: `No existing movie with id ${req.params.id}` });
    res.status(200).json(movie);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const deleteMovie = async (req: Request, res: Response) => {
  try {
    await movieService.deleteMovie(req.params.id);
    res.status(204).send();
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

--------------------------
Path: controllers/event.controller.ts

import type { Request, Response } from "express";
import { EventService } from "../services/event.service.js";

const eventService = new EventService();

export const getAllEvents = async (req: Request, res: Response) => {
  try {
    const events = await eventService.getAllEvents();
    res.status(200).json(events);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const getEventById = async (req: Request, res: Response) => {
  try {
    const event = await eventService.getEventById(req.params.id);
    if (!event) return res.status(404).json({ error: "Event not found" });
    res.status(200).json(event);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const createEvent = async (req: Request, res: Response) => {
  try {
    const event = await eventService.createEvent(req.body);
    res.status(201).json(event);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const updateEvent = async (req: Request, res: Response) => {
  try {
    const event = await eventService.updateEvent(req.params.id, req.body);
    res.status(200).json(event);
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

export const deleteEvent = async (req: Request, res: Response) => {
  try {
    await eventService.deleteEvent(req.params.id);
    res.status(204).send();
  } catch (error: unknown) {
    if (error instanceof Error) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(400).json({ error: "Unknown error" });
    }
  }
};

--------------------------
Path: controllers/auth.controller.ts

import type { NextFunction, Request, Response } from "express";
import { AuthService } from "../services/auth.service.js";
import { AppDataSource } from "../config/database.js";
import { User } from "../models/user.entity.js";
import type { RegisterRequest, LoginRequest } from "../types/auth.types.js";
import { registerSchema, loginSchema } from "../validators/auth.validators.js";

const authService = new AuthService(AppDataSource.getRepository(User));

export const register = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const validatedData: RegisterRequest = registerSchema.parse(req.body);
    const response = await authService.register(validatedData);
    res.status(201).json(response);
  } catch (error) {
    next(error);
  }
};

export const login = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const requestData: LoginRequest = loginSchema.parse(req.body);
    const response = await authService.login(requestData);
    res.status(200).json(response);
  } catch (err) {
    next(err);
  }
};

--------------------------
Path: middleware/auth.middleware.ts

import type { Request, Response, NextFunction } from "express";
import { verifyToken } from "../utils/jwt.js";
import { CustomError } from "utils/customError.js";

export const authenticate = (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    throw new CustomError("Authorization token missing or malformed", 401);
  }

  const token = authHeader.split(" ")[1];
  const decoded = verifyToken(token);
  req.user = decoded as { user_id: string; role: string }; // Attach user info to `req`
  if (!req.user) {
    throw new CustomError("User not authenticated");
  }
  next();
};

--------------------------
Path: middleware/errorHandler.middleware.ts

import type { Request, Response } from "express";
import { CustomError } from "../utils/customError.js";

export const errorHandler = (err: unknown, req: Request, res: Response) => {
  if (err instanceof CustomError) {
    return res.status(err.statusCode).json({ error: err.message });
  }

  console.error("Unhandled Error:", err);
  res.status(500).json({ error: "Internal Server Error" });
};

--------------------------
Path: middleware/validation.middleware.ts

import type { ZodSchema } from "zod";
import type { Request, Response, NextFunction } from "express";
import { CustomError } from "../utils/customError.js";

export const validate =
  (schema: ZodSchema) => (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse({
        body: req.body,
        query: req.query,
        params: req.params,
      });
      next();
    } catch (err: unknown) {
      if (err instanceof Error) {
        next(new CustomError(err.message, 400));
      } else {
        next(new CustomError("Validation Error", 400));
      }
    }
  };

--------------------------
Path: types/auth.types.ts

import type { User } from "../models/user.entity.js";

// Request types
export interface RegisterRequest {
  email: string;
  password: string;
  intro_msg: string;
  username: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

// Response types
export interface RegisterResponse {
  message: string;
  user: Omit<User, "password">; // Exclude the password field
}

export interface LoginResponse {
  token: string;
}

--------------------------
Path: types/express.d.ts

import "express";

declare global {
  namespace Express {
    export interface Request {
      user?: {
        user_id: string;
        role: string;
      };
    }
  }
}

